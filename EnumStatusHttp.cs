using System.ComponentModel;

namespace API_StatusHttp
{
    public enum EnumStatusHttp
    {
        // Informativo
        [Description("A parte inicial de uma solicitação foi recebida e ainda não foi rejeitada pelo servidor. O servidor pretende enviar uma resposta final após o pedido ter sido totalmente recebido e atendido. Quando a solicitação contém um campo de cabeçalho Expect que inclui uma expectativa de 100-continue, a resposta 100 indica que o servidor deseja receber o payload da solicitação. O cliente deve continuar enviando a solicitação e descartar a resposta 100. Se a solicitação não continha um campo de cabeçalho Expect contendo a expectativa de 100-continue, o cliente pode simplesmente descartar essa resposta provisória.")]
        Continue                            = 100,
        [Description("O servidor entende e está disposto a atender a solicitação do cliente, através do campo do cabeçalho de atualização, de alteração do protocolo do aplicativo utilizado nesta conexão. O servidor DEVE gerar um campo de cabeçalho de atualização na resposta que indica qual(is) protocolo(s) será(ão) alterado(s) imediatamente após a linha vazia que encerra a resposta 101. Presume-se que o servidor só concordará em alternar protocolos quando for vantajoso fazê-lo. Por exemplo, mudar para uma versão mais recente de HTTP pode ser vantajoso em relação às versões mais antigas, e mudar para um protocolo síncrono em tempo real pode ser vantajoso ao fornecer recursos que usam tais recursos.")]
        Switching_Protocols                 = 101,
        [Description("Uma resposta provisória usada para informar ao cliente que o servidor aceitou a solicitação completa, mas ainda não a concluiu. Este código de status DEVE ser enviado apenas quando o servidor tiver uma expectativa razoável de que a solicitação levará um tempo significativo para ser concluída. Como orientação, se um método está levando mais de 20 segundos (um valor razoável, mas arbitrário) para processar, o servidor DEVE retornar uma resposta 102 (Processamento). O servidor DEVE enviar uma resposta final após a conclusão da solicitação. Os métodos podem levar potencialmente um longo período de tempo para serem processados, especialmente os métodos que suportam o cabeçalho Depth. Nesses casos, o cliente pode atingir o tempo limite da conexão enquanto espera por uma resposta. Para evitar isso, o servidor pode retornar um código de status 102 Processing para indicar ao cliente que o servidor ainda está processando o método.")]
        Processing                          = 102,

        // Sucesso                          
        [Description("A solicitação foi bem-sucedida. O significado de sucesso depende do método de requisição HTTP. Uma resposta 200 pode ser armazenada em cache por padrão; ou seja, a menos que indicado de outra forma pela definição do método ou controles de cache explícitos.")]
        OK                                  = 200,
        [Description("A solicitação foi atendida e resultou na criação de um ou mais novos recursos. O recurso principal criado pela solicitação é identificado por um campo de cabeçalho Location na resposta ou, se nenhum campo Location for recebido, pelo URI da solicitação efetiva.")]
        Created                             = 201,
        [Description("A solicitação foi aceita para processamento, mas o processamento não foi concluído. A solicitação pode ou não ser atendida, pois pode ser proibida quando o processamento realmente ocorrer. Não há facilidade em HTTP para reenviar um código de status de uma operação assíncrona A resposta 202 é intencionalmente evasiva. Seu objetivo é permitir que um servidor aceite uma solicitação para algum outro processo (talvez um processo orientado a lote que é executado apenas uma vez por dia) sem exigir que a conexão do agente do usuário com o servidor persista até que o processo seja concluído.")]
        Accepted                            = 202,
        [Description("A solicitação foi bem-sucedida, mas o payload incluído foi modificado da resposta 200 OK do servidor de origem por um proxy de transformação. Este código de status permite que o proxy notifique os destinatários quando uma transformação foi aplicada, uma vez que esse conhecimento pode impactar decisões posteriores sobre o conteúdo. Por exemplo, solicitações futuras de validação de cache para o conteúdo podem ser aplicáveis apenas ao longo do mesmo caminho de solicitação (por meio dos mesmos proxies). A resposta 203 é semelhante ao código de Aviso 214 Tranformation Applied, que tem a vantagem de ser aplicável a respostas com qualquer código de status.")]
        Non_Authoritative_Information       = 203,
        [Description("O código de resposta HTTP de status de sucesso 204 No Content indica que a solicitação foi bem sucedida e o cliente não precisa sair da página atual. Uma resposta 204 é armazenada em cache por padrão. Um cabeçalho ETag está incluso na resposta. O caso de uso comum é retornar 204 como resultado de uma solicitação PUT, atualizando um recurso, sem alterar o conteúdo atual da página exibida para o usuário. Se o recurso for criado, 201 Created será retornado. Se a página for alterada para a página recém-atualizada, o 200 deve ser usado em vez disso.")]
        No_Content                          = 204,
        [Description("O servidor atendeu à solicitação e deseja que o agente do usuário redefina a \"visualização do documento\", que fez com que a solicitação fosse enviada, ao estado original recebido do servidor de origem. Esta resposta tem como objetivo oferecer suporte a um caso de uso comum de entrada de dados em que o usuário recebe conteúdo que suporta a entrada de dados (um formulário, bloco de notas, tela, etc.), insere ou manipula dados nesse espaço, faz com que os dados inseridos sejam enviados em um pedido e, em seguida, o mecanismo de entrada de dados é redefinido para a próxima entrada para que o usuário possa facilmente iniciar outra ação de entrada.")]
        Reset_Content                       = 205,
        [Description("O código de resposta do status de sucesso 206 Partial Content indica que a requisição teve sucesso e o corpo contém a sequência (em bytes) dos dados, como descrito no cabeçalho Range da requisição. Se existe somente uma sequência, o Content-Type de toda a resposta é colocado para o tipo do documento, e o cabeçalho Content-Range é provido. Se várias sequências são mandadas como resposta, o Content-Type é colocado para multipart/byteranges e cada fragmento cobre uma sequência, com Content-Range e Content-Type descrevendo-os.")]
        Partial_Content                     = 206,
        [Description("Uma resposta Multi-Status transmite informações sobre vários recursos em situações onde vários códigos de status podem ser apropriados. O corpo de resposta Multi-Status padrão é uma entidade HTTP text/xml ou application/xml com um elemento raiz 'multistatus'. Outros elementos contêm códigos de status de séries 200, 300, 400 e 500 gerados durante a invocação do método. Os códigos de status da série 100 NÃO DEVEM ser registrados em um elemento XML de 'resposta'.")]
        Multi_Status                        = 207,
        [Description("O código de resposta HTTP 208 Already Reported é usado em um 207 (207 Multi-Status) para economizar espaço e evitar conflitos. Se o mesmo recurso for solicitado várias vezes ( por exemplo, como parte de uma coleção ), com caminhos diferentes, apenas o primeiro será relatado com 200. As respostas para todas as outras ligações serão relatadas com este 208 código de status, portanto, nenhum conflito é criado e a resposta permanece mais curta.")]
        Already_Reported                    = 208,
        [Description("O servidor atendeu a uma solicitação GET para o recurso e a resposta é uma representação do resultado de uma ou mais manipulações de instância aplicadas à instância atual. A instância atual real pode não estar disponível, exceto pela combinação desta resposta com outras respostas anteriores ou futuras, conforme apropriado para a(s) manipulação(ões) de instância específica(s).")]
        IM_Used                             = 226,

        //Redirecionamento                  
        [Description("O código de resposta HTTP do status de redirecionamento 300 Multiple Choices indica que a requisição tem uma ou mais possíveis respostas. O agente de usuário ou o usuário devem escolher uma delas. Como não há forma padrão de se escolher uma das respostas, esse código de resposta é raramente usado. Se o servidor tem uma escolha de preferência, ele deve gerar um cabeçalho Location.")]
        Multiple_Choices                    = 300,
        [Description("O recurso de destino foi atribuído a um novo URI permanente e quaisquer referências futuras a este recurso devem usar um dos URIs incluídos. Os clientes com recursos de edição de link devem vincular novamente as referências ao URI de solicitação efetivo a uma ou mais das novas referências enviadas pelo servidor, quando possível.")]
        Moved_Permanently                   = 301,
        [Description("O código de estado HyperText Transfer Protocol (HTTP) 302 Found indica que o recurso foi temporariamente movido para a URL informada pelo cabeçalho Localização. Os navegadores redirecionar para essa página porém os motores de busca não atualizam o link inicial. Mesmo que a requisição requer que o método (e o corpo) não sejam alterados quando o redirecionamento é feito, nem todos os user-agent entram em conformidade - ainda é comum encontrar softwares com bugs neste quesito. Por isso, é recomendado habilitar o código 302 somente em resposta aos métodos GET ou HEAD e utilizar o método 307 Temporary Redirect em outros casos, já que a troca de método é expressamente proibida nesse caso.")]
        Found                               = 302,
        [Description("O código de resposta de status de redirecionamento do HyperText Transfer Protocol (HTTP) 303 See Other indica que o direcionamento não une a um recurso carregado novo, mas a outra página, com uma página de confirmação ou de progresso de carregamento. Este código de resposta normalmente é retornado como resultado de um PUT ou POST. O método usado para mostrar esta página redirecionada é sempre GET.")]
        See_Other                           = 303,
        [Description("O código de resposta HTTP de redirecionamento do cliente 304 Not Modified indica que não há necessidade de retransmitir a requisição de recursos. É um redirecionamento implícito para o recurso em cache. Isto ocorre quando o método de requisição é safe, assim como uma requisição GET ou HEAD, ou quando a requisição é condicional e usa um cabeçalho If-None-Match ou If-Modified-Since.")]
        Not_Modified                        = 304,
        [Description("Definido em uma versão anterior desta especificação e agora está obsoleto, devido a questões de segurança relacionadas à configuração dentro da banda de um proxy.")]
        Use_Proxy                           = 305,
        [Description("HTTP O código de estado 307 Redirecionamento temporário indica que o recurso da requisição foi temporariamente alterado para a URL informada no cabeçalho Location. O método e o corpo da requisição original são reutilizados para realizar a requisição de redirecionamento. Em casos onde você deseja que o método utilizado seja alterado para GET, utilize o código de estado 303 See Other. Isto é util quando você deseja dar uma resposta a um método PUT que não seja o recurso enviado, mas uma mensagem de confirmação (como por exemplo \"Envio de XYZ concluído com sucesso\").")]
        Temporary_Redirect                  = 307,
        [Description("O código de resposta do status de redirecionamento 308 Redirecionamento Permanente do Protocolo de Transferência de Hipertexto (HTTP) indica que o recurso requisitado foi movido definitivamente para o URL dado pelo cabeçalho Localização. O navegador redireciona para essa página e o motor de busca atualiza os seus links para o recurso (na linguagem 'SEO', é dito que o \"suco do link\" ('link-juice') é enviado à nova URL). O método de requisição e o corpo não será alterado, onde talvez o status 301 seja modificado incorretamente para o método GET.")]
        Permanent_Redirect                  = 308,

        //Erro no Cliente                   
        [Description("O código de status de resposta HTTP 400 Bad Request indica que o servidor não pode ou não irá processar a requisição devido a alguma coisa que foi entendida como um erro do cliente (por exemplo, sintaxe de requisição mal formada, enquadramento de mensagem de requisição inválida ou requisição de roteamento enganosa).")]
        Bad_Request                         = 400,
        [Description("O código de resposta de status de erro do cliente HTTP 401 Unauthorized indica que a solicitação não foi aplicada porque não possui credenciais de autenticação válidas para o recurso de destino. Esse status é enviado com um cabeçalho WWW-Authenticate que contém informações sobre como autorizar corretamente. Esse status é semelhante a 403, mas neste caso, a autenticação é possível.")]
        Unauthorized                        = 401,
        [Description("O código de status HTTP 402 Payment Required é um termo despadronizado para respostas de Status, podendo-se ter usos futuros. Às vezes, este comando indica que o processo não pôde ser realizado em função de um pagamento não realizado. Originalmente, foi criado para validar uma micro ou grande transação e pode indicar que o método não se realiza até que o cliente efetue o pagamento. Contudo, não existem usos convecionais fixos e sua inserção varia, dependendo do contexto que é posto.")]
        Payment_Required                    = 402,
        [Description("O código de resposta de status de erro do cliente HTTP 403 Forbidden indica que o servidor entendeu o pedido, mas se recusa a autorizá-lo. Esse status é semelhante ao 401 , mas neste caso, a re-autenticação não fará diferença. O acesso é permanentemente proibido e vinculado à lógica da aplicação (como uma senha incorreta).")]
        Forbidden                           = 403,
        [Description("A resposta de erro 404 Not Found indica que o servidor não conseguiu encontrar o recurso solicitado. Normalmente, links que levam para uma página 404 estão quebrados ou desativados e podem estar sujeitos a link rot. Um código 404 não indica se o recurso está indisponível temporariamente ou se o recurso foi permanentemente removido. Mas, se esse for o caso, o ideal é utilizar o código 410 (Gone).")]
        Not_Found                           = 404,
        [Description("Este status de resposta indica que o verbo HTTP utilizado não é suportado, por exemplo: a requisição ocorre por meio de um get, porém o único método disponível é o POST. Curiosidade: Existem um método chamado OPTIONS que retorna todos os verbos suportados naquela requisição. Obs: ele também pode não ser permitido.")]
        Method_Not_Allowed                  = 405,
        [Description("O código de resposta do erro de cliente 406 Not Acceptable indica que o servidor não pode produzir uma resposta que combine com a lista de valores aceitáveis definidas nos cabeçalhos de negociação de conteúdo da requisição proativa, e o servidor é incapaz de produzir uma representação padrão.")]
        Not_Acceptable                      = 406,
        [Description("O código de resposta HTTP **407 Proxy Authentication Required **indica um erro do lado cliente, informando que uma solicitação não está sendo bem aplicada. Isso ocorre porque falta a validar as credencias de autenticação para um proxy server que intermedia o navegador e o servidor que pode acessar o recurso solicitado. Este erro é enviado com um cabeçalho Proxy-Authenticate que contém informações de como fazer uma autorização correta.")]
        Proxy_Authentication_Required       = 407,
        [Description("A resposta 408 Request Timeout significa que o servidor irá encerrar essa conexão em desuso. É enviado a uma conexão parada por alguns servidores, mesmo sem nenhuma requisição feita anteriormente pelo cliente. O servidor deve enviar no cabeçalho de resposta \"close\" Connection já que 408 implica que o servidor decidiu encerrar a conexão ao invés de continuar aguardando. Essa resposta está sendo mais usada desde que alguns browsers como Chrome, Firefox 27+, e IE9, usam o mecanismo \"HTTP pre-connection\" para acelerar a navegação.")]
        Request_Timeout                     = 408,
        [Description("O status de resposta 409 Conflict indica que a solicitação atual conflitou com o recurso que está no servidor. Conflitos são mais frequentes quando usado o método PUT. Por exemplo, você pode receber uma resposta 409 quando fizer upload de um arquivo que é mais antigo do que já existe no servidor, resultando em conflito de versão.")]
        Conflict                            = 409,
        [Description("O código de resposta HTTP 410 Gone de erro do cliente indica que o acesso ao recurso não está mais disponível no servidor de origem, e que esta condição tende a ser permanente. Se você não sabe se a ausência do recurso é temporária ou permanente, o código de status 404 deverá ser utilizado.")]
        Gone                                = 410,
        [Description("O código de resposta 411 Length Required de erro de cliente do Protocolo de Transferência de HyperTexto (HTTP) indica que o servidor se nega a aceitar a requisição sem um cabeçalho Content-Length definido.")]
        Length_Required                     = 411,
        [Description("O código de resposta de erro de cliente HTTP 412 Precondition Failed indica que o acesso ao recurso especificado foi negado. Isso acontece com requisições condicionais em métodos que não GET ou HEAD quando a condição definida pelo cabeçalho If-Unmodified-Since ou If-None-Match não é satisfeita. Nesse caso, a requisição, geralmente um upload ou modificação de um recurso, não pode ser feita e o código de error de resposta é enviado de volta.")]
        Precondition_Failed                 = 412,
        [Description("O código de resposta HTTP 413 Payload Too Large indica que a carga da requisição é mais larga que os limites estabelecidos pelo servidor; o servidor pode encerrar a conexão ou retornar Retry-After no campo de cabeçalho.")]
        Payload_Too_Large                   = 413,
        [Description("O código de resposta 414 URI Too Long indica que o tamanho da URI requisitada pelo cliente é maior do que o tamanho que o servidor aceita interpretar.")]
        Request_URI_Too_Long                = 414,
        [Description("O erro HTTP 415 Unsupported Media Type do cliente indica que o servidor se recusou a aceitar a requisição porque o formato do payload não é um formato suportado. O problema do formato por ter ocorrido pelos valores indicados no Content-Type ou Content-Encoding, ou pelo resultado da inspeção do dado em si.")]
        Unsupported_Media_Type              = 415,
        [Description("O código de erro de resposta HTTP 416 Range Not Satisfiable indica que o servidor não pode servir as sequências solicitadas. A razão mais provável é que o documento não contenha tais sequências, ou que o valor do cabeçalho Range, apesar de sintaticamente correto, não faça sentido. A mensagem de resposta 416 contém um cabeçalho Content-Range indicando uma sequência insatisfatória (que é um '*') seguido por uma '/' e o tamanho atual do recurso. E.g. Content-Range: bytes */12777")]
        Requested_Range_Not_Satisfiable     = 416,
        [Description("O codigo de erro de cliente HTTP 417 Expectation Failed indica que a expectativa enviada no cabeçalho da requisição Expect não foi suprida. Veja o cabeçalho Expect para mais detalhes.")]
        Expectation_Failed                  = 417,
        [Description("O código de erro HTTP para o cliente 418 I'm a teapot indica que o servidor se recusa a preparar café por ser um bule de chá. Este erro é uma referência ao Hyper Text Coffee Pot Control Protocol, que foi uma piada de 1º de abril de 1998.")]
        Im_a_teapot                         = 418,
        [Description("A solicitação foi direcionada a um servidor que não pode produzir uma resposta. Isso pode ser enviado por um servidor que não está configurado para produzir respostas para a combinação de esquema e autoridade que estão incluídos no URI do pedido. Os clientes que recebem uma resposta de 421 Solicitação mal direcionada de um servidor PODEM tentar novamente a solicitação - seja o método de solicitação idempotente ou não - por meio de uma conexão diferente.")]
        Misdirected_Request                 = 421,
        [Description("O codigo de resposta HTTP 422 Unprocessable Entity indica que o servidor entende o tipo de conteúdo da entidade da requisição, e a sintaxe da requisição esta correta, mas não foi possível processar as instruções presentes.")]
        Unprocessable_Entity                = 422,
        [Description("O recurso de origem ou destino de um método está bloqueado. Esta resposta DEVE conter um código de pré-condição ou pós-condição apropriado, como 'lock-token-submitted' ou 'no-conflicting-lock'.")]
        Locked                              = 423,
        [Description("O método não pôde ser executado no recurso porque a ação solicitada dependia de outra ação e essa ação falhou. Por exemplo, se um comando em um método PROPPATCH falhar, então, no mínimo, o restante dos comandos também falhará com 424 Dependência com Falha.")]
        Failed_Dependency                   = 424,
        [Description("O status HTTP 426 Upgrade Required indica que o servidor recusa o processamento da requisição usando o protocolo atual mas poderá ser processado caso o cliente atualize para um protocolo diferente. O servidor envia uma header Upgrade (en-US) com esta resposta para indicar qual o protocolo necessário.")]
        Upgrade_Required                    = 426,
        [Description("O codigo de resposta HTTP 428 Precondition Required indica que o servidor precisa que a requisição seja condicional (en-US). Normalmente, isto significa que um cabeçalho pré-requisito, como o If-Match, está faltando. Quando o cabeçalho pré-requisito não é o mesmo esperado pelo servidor, a resposta deve ser 412 Precondition Failed.")]
        Precondition_Required               = 428,
        [Description("O código de resposta HTTP 429 Too Many Requests indica que o usuário enviou muitos pedidos em um determinado período de tempo. Um header Retry-After pode ser incluído na resposta indicando quanto tempo o usuário deve esperar antes de fazer um novo pedido.")]
        Too_Many_Requests                   = 429,
        [Description("O código de stauts de resposta HTTP 431 Request Header Fields Too Large indica que o servidor se recusou a processar a requisição por que os cabeçalhos HTTP da mesma são muito grandes. A requisição pode ser resubmetida depois de o tamanho dos cabeçalhos serem reduzidos. 431 pode ser usado quando o tamanho total dos cabeçalhos da requisição são muito grandes, ou quando um único cabeçalho da requisição é muito grande.")]
        Request_Header_Fields_Too_Large     = 431,
        [Description("Um código de status não padrão usado para instruir o nginx a fechar a conexão sem enviar uma resposta ao cliente, mais comumente usado para negar solicitações mal-intencionadas ou malformadas. Este código de status não é visto pelo cliente, ele aparece apenas nos arquivos de log do nginx.")]
        Connection_Closed_Without_Response  = 444,
        [Description("O código de erro HTTP para o cliente 451 Unavailable For Legal Reasons indica que o recurso solicitado pelo usuário não está disponível por motivos legais, como em uma página web para a qual foi emitida uma ação legal.")]
        Unavailable_For_Legal_Reasons       = 451,
        [Description("Um código de status não padrão introduzido pelo nginx para o caso em que um cliente fecha a conexão enquanto o nginx está processando a solicitação.")]
        Client_Closed_Request               = 499,

        //Erro no Servidor                  
        [Description("Quando o servidor retorna um código de erro (HTTP) 500, indica que encontrou uma condição inesperada e que o impediu de atender à solicitação. Essa resposta de erro é uma resposta genérica \"abrangente\". Às vezes, os arquivos log de servidores podem responder com um status code 500 acompanhado de mais detalhes sobre o request para evitar que no futuro erros desse tipo possam voltar a acontecer.")]
        Internal_Server_Error               = 500,
        [Description("O código de resposta HTTP 501 Not Implemented indica que o servidor não suporta a funcionalidade requerida para completar a requisição. Esta é a resposta apropriada para quando o servidor não reconhece o método requisitado e não tem capacidade de suporta-lo para nenhum recurso. Os únicos métodos de requisição que os servidores suportam obrigatóriamente ( e, portanto, isso não deve retornar este código) são GET e HEAD.")]
        Not_Implemented                     = 501,
        [Description("O código de erro HTTP 502 Bad Gateway retornado pelo servidor indica que ele, enquanto atuando como um servidor intermediário (gateway ou proxy), recebeu uma resposta inválida do servidor para o qual a requisição foi encaminhada (upstream server).")]
        Bad_Gateway                         = 502,
        [Description("O código de resposta de erro de servidor 503 Service Unavailable do HTTP indica que o servidor não está pronto para lidar com a requisição. Causas comuns são um servidor que está em manutenção ou sobrecarregado. Esta resposta deve ser usada para condições temporárias, e o cabeçalho HTTP Retry-After deve, se possível, conter o tempo estimado para restabelecimento do serviço.")]
        Service_Unavailable                 = 503,
        [Description("O código de resposta de erro HTTP 504 Gateway Timeout indica que o servidor, enquanto atuando como gateway ou proxy, não conseguiu responder em tempo. Um Gateway pode referir-se a diferentes elementos de rede e um erro 504 geralmente é algo que você não pode consertar, mas solicitar uma correção no servidor web ou proxy no qual você está tentando acessar.")]
        Gateway_Timeout                     = 504,
        [Description("O código de resposta de status HTTP 505 HTTP Version Not Supported indica que a versão HTTP utilizada na requisição não é suportada pelo servidor.")]
        HTTP_Version_Not_Supported          = 505,
        [Description("O código de status de resposta HTTP 506 Variant Also Negotiates pode ser dado no contexto de Negociação de Conteúdo Transparente (Transparent Content Negotiation) (veja RFC 2295). Esse protocolo permite ao cliente requerer a melhor variante de um dado recurso, onde um servidor fornece múltiplos variantes. O código de status Variant Also Negotiates indica um erro na configuração interna do servidor na qual a variante escolhida é em si configurada para entrar em uma negociação de conteúdo, então não é um endpoint de negociação apropriado.")]
        Variant_Also_Negociates             = 506,
        [Description("O código de resposta de status HTTP 507 Insufficient Storage pode ser usado no contexto do protocolo Web Distributed Authoring and Versioning (WebDAV) (veja RFC 4918). Isso indica que o método não pode ser executado porque o servidor não pode salvar a representação necessária para completar a requisição com sucesso.")]
        Insufficient_Storage                = 507,
        [Description("O código de resposta de erro HTTP 508 Loop Detected pode ser retornado em um contexto do protocolo Web Distributed Authoring and Versioning (WebDAV) . Indica que o servidor finalizou uma operação porque encontrou um loop infinito enquando processava a requisição com \"Depth: infinity\". Esse código indica que toda a operação falhou.")]
        Loop_Detected                       = 508,
        [Description("O código de status da resposta HTTP 510 Not Extended é enviado no contexto do HTTP Extension Framework, definido na RFC 2774. Na especificação, um cliente pode mandar uma requisição que contenha uma declaração de extensão, que descreve a extensão a ser utilizada. Se o servidor aceitar tal requisição, mas quaisquer extensões descritas na requisição não forem suportadas, o servidor então retorna uma resposta com o código de status 510.")]
        Not_Extended                        = 510,
        [Description("O código de erro HTTP para o cliente 511 Network Authentication Required indica que o cliente precisa realizar uma autenticação para utilizar a rede. Esse status não é gerado pelos servidores de origem, mas pela interceptação de proxies que controlam o acesso à rede. Às vezes, as operadoras de rede exigem alguma autenticação, aceitação de termos ou outra interação do usuário antes de conceder acesso (por exemplo, em um cyber café ou em um aeroporto). Eles geralmente identificam clientes que não o fizeram usando seus endereços de Controle de Acesso à Mídia(MAC)")]
        Network_Authentication_Required     = 511,
        [Description("Este código de status não é especificado em nenhum RFC, mas é usado por alguns proxies HTTP para sinalizar um tempo limite de conexão de rede atrás do proxy para um cliente na frente do proxy.")]
        Network_Connection_Timeout_Error    = 599
    }
}